In version 1.00
-Va verdeeld over x=0 en x=L
-symmetrisch exponentieel grid bij de contacten, vorm bepaald door grad
-input vanuit een file
-Braun met verschillende distributies
-veld-afhankelijke mobiliteit (of: plaats-afhankelijk)
-betere gok van nieuwe slotboomvariabelen na het ophogen van de spanning
-de slotboomvariabelen zijn via een 'similarity scaling' geschaald, zie
 IEEE trans. elec. dev. aug. 73 p. 669
-Gummel iteratie: Poisson oplossen met gok voor n en p
 en dan met de nieuwe Vi+1, nieuwe ni+1 en oude pi de recombinatie
 uitrekenen en de electronen cont. eq. oplossen voor ni+1. Dan pi+1 oplossen
 uit cont. eq. met nieuwe waarden van V, n en p




In version 1.10 (May & Aug 2004)

Electron and hole traps (single level) have been included. To do this, a new form of 
Poisson's eq is derived to again linearize this eq. In the Poisson solving procedure,
a check is performed whether traps are present or not, to avoid doing a lot of unneces-
sary calculations.

for single level: Lampert and Mark (2.17) 

n_trap: density of filled electron traps
p_trap: density of filled hole traps
Nt: trap density 
Pt: hole trap density
Entrap: energy of electron trap w.r.t. conduction band
Eptrap: energy of hole trap w.r.t. valence band

Output for final voltage changed: phi_n,p as well as n, p are written in the output file, 
slotn,p are canceled


Version 1.15 (sep 2004)
Exponential trap distributions have been added. 
See: Kao & Hwang (3.4.2) (p. 160)
Four new parameters have been added in device_parameters.txt:
Ntrtype, Ptrtype: electron/hole trap type, indicating whether the traps are exponential or
single level.
Tntr, Tptr: characteristic trap temperature for exponential distribution.
The trap density expression (exp.) is written as a first order Taylor expansion in \delta V
to yield the necessary correction term (main diagonal). Terms (1-Ntrtype), (Ntrtype), etc.
select the appropriate terms in the Poisson matrix.

Version 1.16 (Sep 2004)
I have made a better guess for the new potential at the beginning of the main loop: previously,
the guess was a linear function from contact to contact. Now, it is the old potential plus
a linear function yielding half the voltage step (Va-Vaold) at the contacts. In this way, the
new potential has the form of the old potential, and is not a straight line. Convergence is 
faster for non-uniform potential, e.g., near the built-in voltage.

Version 1.17 (Sep 2004)
-The version number and number of points are printed right at the beginning of the program
-A new mobility dependence has been added: both field- and concentration dependent. Further-
more, the concentration dependent mobility (nr. 2) has been changed to Vissenberg + mu_0,
in accordance with Cristina's work. The field- and concentration dep. mob. (nr. 3) has an
exponential field activation prefactor.
-The field activation factor, which was called alfa_n,p in previous versions, has been 
renamed and is now called gamma_n,p, to avoid confusion with the effective overlap parameter
in the Vissenberg model.

version 1.18 (Oct. 2004)
A bug has been removed from version 1.17: in the procedure calc_hole_mob in case 2 the 
dum2 variable was calculated with T0n instead of T0p. Furhtermore, the mun and mup variables are
also printed in the var_file. Two new variables have been introduced: Pause_at_end and 
Warn_mob_dep to improve the user friendliness. Pause_at_end determines whether the program 
should pause at the end, while Warn_mob_dep determines whether a warning should be given
if mob_n_dep <> mob_p_dep. 

version 1.18A (July 2005)
A bug was removed from the function Interpolation, we have to use ns+1 instead of ns in 
the IF statement (IF 2*(ns+1) < n-m).

Version 1.20 (Dec. 2004)
The possibility of reading in a generation rate profile from the file 'generation_profile.txt'
has been added. This file should not contain any comments, just the position x[m] and the 
generation rate [m^-3 s^-1], separated by a space or tab. The last x value should corres-
pond to the device thickness L, specified in the device_parameters.txt. However, the 
'grid' of the generation profile does not have to match the grid in the program, nor the
number of points used (NP). Linear interpolation is used to obtain the generation rate in
each grid point in the program. 
The variable Gen_profile (integer) denotes whether this profile should be used (1) or not (0).
The generation in each grid point is subsequently stored in the array Gm. In the case of
a constant generation of bound e/h pairs, Gm will be equal to Gmax (previously called Gm).
Otherwise, the data will be read and Gm will be filled by the generation profile obtained
from the file.
Note that as long as Gen_profile = 0 in the device_parameters file, it is not necessary
that the generation_profile file exists.


Version 1.21 (Jan. 2005)
The the function Norm the variable ans is changed from DOUBLE to EXTENDED, allowing for 
larger slotboom variables. Note: Norm calculates the norm of the slotboom vectors. The 
voltage range could thus be extended to +- 34V at 295 K.


Version 1.22 (April 2005)
I have replaced the norm used in the program (function Norm) by the infinity norm, i.e., 
norm(x) = Max |xi|, making the program just a little bit faster. Furthermore, I have renamed Vconv
to Vacc (accumulation voltage) and incorporated a program halt if Vmin=Vmax when Vdistribution=2, 
previous versions entered an infinite loop for Va in this case.

version 1.23 (July 2005)
A bug was removed from the function Interpolation, we have to use ns+1 instead of ns in 
the IF statement (IF 2*(ns+1) < n-m). What is more, the last (=maximum) x-coordinate in the
generation_profile.txt file no longer has to be equal to L. Instead, it is rescaled to L, so the
x-coordinates in the generation_profile are now given in relative units.


Version 2.00 (Nov.+ Dec 2005)
First of all the name of the program has been changed to SIMsalabim. Furthermore, the welcoming 
message was modified, now stating the author's name at start-up.
Perhaps the most important change in this version is the introduction of natural variables (V,n,p)
to replace the Slotboom variables (V, slotn, slotp). A straightforward change in the code, except
for the Poisson solver. In the original Gummel scheme, the Poisson equation is solved in conjunction
with the quasi-fermi levels, which remain unchanged. As a consequence, the actual value for the 
electron and hole densities changes when the Poisson equation is solved, since the potential is 
modified. This lies at the heart of the Gummel scheme, therefore, at the end of the loop in
the Poisson solving procedure, the densities are explicitely modified according to the new potential.
Note that this excludes (without loss of stability) the possibility of a direct (i.e., non-iterative) 
way of solving the Poisson equation. The benefits of natural variables are two-fold: the voltage
range is greatly increased (17 times larger!) and the program has become more transparent since
the natural variables are more intuitive.
A new convergence criterion has been introduced: the convergence of the overall current density Jtot. 
Since this is the main parameter of interest, this seems a logical variable to monitor when fitting
JV-characteristics. It should be noted that when one is interested in the densities, potential, etc. 
the device, it is much better to check the convergence of the Slotboom variables. A new parameter
was added to the device_parameters file, Conv_Var, in order to select the parameter (Jtot or the
Slotboom vars) should be monitored. Conv_var = 1 selects the Jtot, in all other cases, i.e., 
Conv_Var<>1, the Slotboom variables are monitored. To get a good JV-characteristic, a tolerance
of 1e-2 to 1e-3 should be enough when Conv_Var=1. The way the program checks for convergence was also 
changed: a new Boolean variable Conv_Main is used to monitor the convergence. Note that when 
Jtot=0 the Slotboom variables are used to check for convergence to aviod division by zero.
In the procedure make_grid, the range of the third for-loop was changed from 0-NP+1 to 0-NP, since 
k[NP+1] does not exist. Consequently, the value of x[NP+1] is now realy equal to L.
Another addition to this version is the incorporation of Shockley-Read-Hall (SRH) recombination, i.e.,
recombition of free holes with trapped electrons. Two new parameters in the device_parameters file
were introduced (Cn and Cp), namely the capture coefficient for electrons and holes. When either one
of the parameters are equal to zero, SRH recombination is not taken into account. The procedure
Calc_SRH_Prefactor calculates the SRH prefactor (srhp), i.e., R_SRH = srhp * (np - n_int^2) is the
rate of SRH recombination. This prefactor is stored in a new array srhp, much in the same way as
Langevin recombination is treated. In the case of an exponential distribution of electron traps, 
an integration over the trapping levels is needed in order to calculate the srhp. 
As a last change, the continuity equations have been rewritten in a slightly simpler form. 


Version 2.01 (Jan 2006)
The procudure heading of Solve_Poisson was modified. In the previous (2.00) version, the electron and
hole densities (n,p) were declared as value parameters, meaning that any changes to n and p did
not affect the values of n and p outside the scope of the Solve_Poisson procedure. This is in 
conflict with the Gummel scheme (and with the previous Slotboom versions), since this scheme requires
that the densities are changed whenever the Poisson equation is solved. Therefore, n and p are
now declared as var parameters.


2.02: left <> right
JCList, Find_Solar_Cell_Parameters, convergence.


3.00 (Sep. 2009, TUE)
Modified the program so it can read in a table for the electron mobility. The mobility, as a function of F and n, is interpolated (bilinear interpolation). 

3.01 (Sep. 2009):
Included Pasveer's formula (PRL 94, 206601) for the electron mobility.

3.02 (March 2010):
fixed a bug in Init_Generation_Profile: when using a generation profile, there was chance of a range check error occuring: 

3.03
Not documented.

3.04 (Feb. 2011)
Added a new mobility model (Koster's Marcus hopping mobility).

3.05 (23 Feb. 2011)
Modified the way the currents are calculated and the continuity equations so the Einstein relation is no longer assumed. The values of Dn,p (diffusivities) are calculated each loop, either by assuming the Einstein relation (Dn,p_dep=0) or by using an aditional scaling factor (eta_n,p) if Dn,p=1. I plan to use the full Roichmann-Tessler expression in a later version.

3.06 (17 March 2011)
Added two new columns to the JV output file: recLan and recSRH. These show the average rate of Langevin and SRH recombination resp. In both cases, photogeneration of carriers is excluded from the rate calculation. Also, implemented a function 'average' that calculates an average value of the input vector. To calculate recLan and recSRH an empty vector (containing only zeros) is passed to function recombi.

3.07 (1 April 2011)
Added a new procedure: Solve_Poisson_Direct. This solves V directly from n and p and can only be used in the absence of traps. There are two reasons for implementing this procedure:
1) Using a generalised form of the Einstein relation (Dn,p_dep <> 0) affects the way the iterative Poisson solver should be implemented as there are many Vt terms in these equations. However, I chose not to change this procedure as it doesn't seem to make much of a difference. As the iterative procedure only slightly alters n and p the effect of eta_n,p not being 1 is not that important.
2) It can (but this is not always the case!) make the simulation faster.
Caveat: if we replace the old values of V with the newly (directly solved) one, the program sometimes fails to converge and starts to oscilate. Therefore, I've implemented a parameter (mixV), so the new value is: V:=mixV*Vold + (1-mixV)*V. Obviously 0<=mixV<1.
I have not (yet) implemented trapping in the direct Poisson solver, so the program halts if trapping is used in conjunction with the direct solver.
 
3.08 (24 May 2011:))
Removed a bug: the Pasveer formula wasn't implemented correctly as I had inadvertently left out the 1.8e-9 prefactor. Also implemented an improved parameterisation of Pasveer's data (see Current Applied Physics 10 (2010) 1182\961187).

3.09 (31 May 2011)
Changed the definition of the contacts: Instead of electron/hole Ohmic or neutral, it is now possible to set a barrier at both the left and the right contact. The left[right] one (phi_left[right], eV) corresponds to the injection barrier for electrons[holes], the barrier for the other carrier is equal to Egap-phi_left[right]. Note that, as before, barrier lowering etc. is not accounted for. Therefore, the barriers should be chosen small enough to render those effects negligible.

3.10 (24 June 2011)
Removed a bug: In 3.09 the net recombination in the var_file was zero (bug). Now the net recombination rate is calculated immediately prior to writing all the variables to the var_file.

3.11 (14 March 2012)
I've exchanged the procedures that calculate the current density based on De Mari's paper with procedures based on Selberherr eq. 6.1-39 and 6.1-41. The latter, of course, modified for generalised Einstein relations and corrected for the sign. 
Also, I've implemented a faster approximation for the Bernoulli function based on different Taylor series. This makes the program about 2-3 times faster.

3.12 (15 March 2012)
I've implemented finite surface recombination velocities (Sn,p) for minority carriers at the contacts. Of course Sn,p = 0 doesn't work. Negative values are interpreted as infinite surface recombination, which means that the minority carriers simply have their equilibrium values. Note, this is effectively what SIMsalabim did up till 3.12. 
For finite, positive Sn,p we try to get n(p) at the anode (cathode) from J = q Sn(p) (n(p) - n(p)eq). This is done by using a bisection algorithm. At the start of each voltage loop, nmin=neq and nmax=Nc. These serve as lower and upper bounds respectively. Then we gauge whether n is too big or small (procedure Density_from_surface_rec). If it's too big, we make nmax equal to the current n. If it's too small we make nmin equal to the current n. Then we take the geometric mean (i.e. the mean of the logarithms of n). 
Note that using Sn,p>0 only makes sense if electrons are minority carriers at the right electrode (=anode!). So, the programs checks if the right electrode really is the anode.
Similarly for holes.

3.13 (28 March 2012)
I have introduced doping. The device_parameters.txt file specifies (n_0, p_0) the density of ionised dopants. Note that if traps are also present a fraction of the traps will be filled by doping. This, however, is not included in this version. So, if N(P)t<>0 and n(p)_0<>0 the program halts. 

3.14 (8 May 2012)
I have introduced a second photogeneration process: If photogeneration is field dependent, the user can specify how many (fraction, P0) of quenched excitons directly yield free carriers. The other quenched excitons are assumed to yield CT states first, which can be dissociated according to the Onsager-Braun model. So, G[i]:=(P0 + (1-P0)*dp[i]) * Gm[i] and the bimolecular recombination rate is unchanged. Note, that the AV_diss only refers to the CT process!

3.15 (8 May 2012)
I've improved the Bessel function. Instead of that horrible power function stuff, I use a proper polynomial. Of course, this is based on the exact same Taylor expansion, but written is a much more (3x faster!) efficient form. The resulting code is about 3x faster if field-dependent generation is being used.

3.16 (27 Aug 2012)
Changed the way the Voc is estimated. The previous estimate did not always bracket the Voc. Now, we start at the lowest V in the JV curve, and move to the right, checking every time whether the sign of the resulting current J changes. If so, we're just past Voc. Then we use linear interpolation to find Voc. The error estimate of Voc is equal to half the voltage step between the points that bracket Voc. Simple and stable.

3.17 (13 Nov 2012)
Previously, the generation profile (if used, that is) was used directly to determine the bound pair generation rate, so intensity dependent simulations were hard to do: Gmax was not used. Now, the generation profile yields the shape, but not the height/magnitude of the generation rate. Gmax is used as the maximum of the generation rate (in space), so the overall magnitude is controlled by Gmax. The VAR file also lists the local generation rate.

3.18 (18 Feb 2013)
Added Pasveer model, Marcus mobility and improved Pasveer model for holes.

3.19 (21 Feb 2013)
I have implemented SOR and SUR in the Poisson solver and the main loop (where it changes the densities). This can potentially be used to make the program converge quicker, but it is perhaps more useful in slowing it down: If the density dependence of the mobilities is very strong, the pervious versions had difficulty converging. Herman solved this by introducing an averaging procedure over the mobilities obtained in different loops. I chose SOR/SUR as it's simple, well known and can even make it run faster. Note that SUR was already implemented in the direct Poisson solver. Two parameters control SOR/SUR: accPois (Poisson solver) and accDens (density in main loop). Note that setting these close to zero will make the changes in V,n,p per loop very small and the program might conclude that the solution converged as it monitors the change in a loop, not the actual error.

3.20 (28 Feb 2013)
Removed a bug: in  3.18 and 3.19 the doping densities were accidentally removed from the trap-free Poisson equation. Now they're back. Also, I've introduced field-ionisation of the dopants. n_0 and p_0 now are the zero-field ionised dopants densities. Doping is ionised in a Poole-Frenkel like expression using field activation parameters beta_n and beta_p. 

3.21 (10 Sep 2014)
I have made the simulations with finite surface recombination more rebust. To do so, the minority densities at the contacts are no longer updated during every main loop, but only after the main loop appears to have converged. Then, the minority densities are updated and the main loop continues. Only if the change in the minority densities is smaller than tolMain do we consider the main loop to have fully converged.

3.22 (28 Oct 2014)
I have added the possiblity of including leakage current. In the 'contacts' section of the parameters, the shunt resistance (Ohms/m2) is defined. If a positive value is used, the leakage current density (Va/Rshunt) will be added to the total current density (Jot). To exclude leakage, use a negative value for Rshunt (is equivalent to infinite Rshunt).

3.23 (8 Jan 2016)
I have incorporated the changes suggested by Niels van der Kaap regarding finite surface recombination. Niels suggested that the continuity equations for finite surface recombination can be solved directly. To do this, one uses another tridiagonal matrix solver (tridiag_2, was already in the code) to solve on all grid points, so including i=0 and i=NP+1 (i.e. the contacts). The surface recombination velocities can now also be set to 0. Both majority and minority surface recombination velocities can be set for electrons and/or holes.

3.24 (04 Feb 2016)
Edit by V LE CORRE (VLC)
Version updated to be control by the cmd windows.
Functions added using function from SimBAM: Prepare_Log_File, Get_String, Get_Integer, Get_Float, Read_Name(updated) and Read_Parameters(updated).

3.25 (17 March 2016), LJAK
I removed a bug from the continuity solvers: When finite surface recombination velocities are used the previous versions were wrong. This is because a factor L was missing (the grid spacing h[i] is scaled to L) and the sign was wrong. The sign is a bit tricky. We always write: Jn=qS(n-neq), but that implies that Jn > 0 for finite S. However, we change the sign in Calc_elec_curr because we like to have Jsc<0. 

3.26 (31 March 2016), LJAK
I have incorporated image-force-lowering of injection barriers. This only works for infinite surface recombination. Also, it only considers lowering of the barrier for electrons at the left electrode and holes at the right electrode. The model that I implemented is the one described by Scott&Malliarias (Chem Phys Lett 199, 115 (1999)). They introduce a formula for the carrier density at the contact due to image-force-lowering. I use this formula to calculate n[0] and p[NP+1]. Next, the law of mass action is used to get the minority carrier density at the contact and the Boltzmann equation is usde to calculate the effective barrier height (phi_left/right_eff). This is then used to change the boundary condition in the potential V.
I have also introduce two parameters (RoughLeft/Right) to take the effect of surface roughness at the electrodes into account. Surface roughness enhances the local electric fields, which makes injection (even) stronger. This is described by George Palasantzas et al, PRB 60, 9157 (1999). Setting RoughLeft/Right to zero means that this effect is ignored.
Minor changes: I have changed the matrix elements at the contacts for infinite surface recombination (otherwise it wouldn't work well with image-force-lowering). In the main loop, SOR/SUR is now done for all grid points (including 0 and NP+1). 



Version 3.27 (8 April 2016), LJAK
I have removed a bug from 3.26: In this version, I had introduced image-force-lowering (IFL). In every loop, the densities at the contacts are adjusted to account for IFL (if needed) and the potentials at the contacts V0 and VL are changed (which means that the injection barrier changes). The latter, of course, changes the applied electric field in the active layer. This means that the potential changes for all grid points, even if the densities wouldn't change. Therefore, I had mistakenly added a for-loop to change the potential in all grid points (line 1835). This was not done correctly: it was a simple linear interpolation of the potential, just like we use when initialising the simulation. I have simply removed this loop. The Poisson solver ensures that the correct electric field is applied inside the active layer. 


Version 3.28 (8 July 2016), TSS (Tejas S. Sherkar)
I included the p and n insulating layers to simulate p-i-n structures. Ofcourse the thicknesses of these layers (LIL, LIR) can be set to zero to simulate m-i-m devices. Dielectric constant can be set independently for p, i, n layers. Included generalised potential for use of offsets between p-i and i-n layers. Generation in p and n layers can be swtiched off.
Important: So, now the device thickness (L) should be set manually to your absorber + n-layer + p-layer thickness. 
Also included defect layers (thicknesses can be changed) at p-i interface (hole traps) and i-n interface (electron traps). These defect layers are part of the i (absorber) layer.
I included ions (+, - and both species) in i layer. Infinitely fast and slow scan possible by setting fix_ions.
Inluded preconditioning voltage (Vpre). This is the voltage at which ion densities are solved and then a voltage sweep is possible from any voltage point. Set equal to zero for infinitely slow scan (fix_ions=0).
Included intermediate scan rate (kind of). Can be set by putting fix_ions=0 and scan_rate from 0 to NJV. Resulting JV file then contains JV points for voltages just after the ion distribution happens.
Included voltage scan direction (SC-OC, OC-SC).
Couple ion densities to Poisson solver (just like for n and p).


Version 3.29 (6 Oct 2016), LJAK
I have extended the effects of spurious resistances to include the effect of (external) series resistance. The series resistance is set by parameter Rseries (Ohms/m2). The program now stores 2 JV curves: the intrinsic ('normal') one (JV_char) and the one that is affected by series/shunt resitances (JV_char_ext). The latter is the one you would measure externally. Both JV curves are stored in JV_file, but only the normal JV is shown on screen.
When the main loop is done, first the current density is computed and the normal JV curve (current voltage point) is updated. Then, the external  voltage and current are calculated and stored. When all voltages have been simulated, the FF, Jsc, Voc, etc is calculated for the normal JV curve and also for the external one if Rseries>0 or Rshunt>0.


Version 3.30 (6 Feb 2017), TSS
I have removed the bug from 3.29: In this version, when Nt = 0 the SRH recombination was zero despite there being interface traps (specified by St_L, St_R). 
Now, the boolean 'Traps' is updated after reading in all of the trap parameters (in v3.29 the update was after reading reading Nt, hence the bug). The IF statement in the Calc_SRH_Prefactor has been accordingly modified to include the boolean condition.

Version 3.31 (24 Feb 2017), VLC
I included the possibilty of setting Lang_pre as Gamma when calculating the recombination such as rec = Lang_pre(np -ni^2).
Lang_rec parameter control whether we want to use Langevin formula or not. 

Version 3.32 (16 Mar 2017), TSS
I have included the sign of the filled trap. One can set it to 0 or 1 for neutral or charged filled trap respectively.
Also, the correct formulation of ptd (dummy used in Poisson loop) is =(p[i]/Nc)*EXP(Eptrap/Vt) and not (Nc/p[i])*EXP(-Eptrap/Vt). It has now been corrected.


Version 3.33 (20 March 2017), LJAK
I have removed a bug: In 3.32 the electron (hole) mobility in the HTL (ETL) layer was set to 1e-7 times that of the hole (electron) mobility in said layer (last line of Calc_elec_mob and Calc_hole_mob). This was done to simulate the blocking behaviour of these transport layers. However, blocking is accomplished via the energy offests, not via the mobilities. A low minority carrier mobility means that (in steady-state) the transport layers fill up with minority carriers as they are too slow to be extracted. That is the opposite of what we wanted to achieve.


Version 3.34 (11 Sept 2017), VLC
Now the simulation also output and device performance file (Perf_file) which include Jsc, Voc, Vmpp, MPP and FF when the can be calculated. The name of the device performance file can be changed in the device_parameters.txt file (Perf_file).

Version 3.35 (13 Sept 2017), VLC
Now Gmax is set as the average value of the generation rate. A new function Average_limited_range has been created to calculate the average of a vector between two index (i1 and i2 index of the insulators) it also normalized the vector before calculating the average.
The function init_generation_profile has been updated such as now when the insulators don't absorb the generation profile is rescaled between i1 and i2 and then the input Gmax is set as the average of the profile between i1 and i2.

Version 3.36 (16 Sept 2017), VLC
I have removed a bug from 3.34 the Perf_file is now written only when the FF can be calculated.

Version 3.37 (27 Sep 2017), LJAK
I have changed the way a generation profile is specified and made it more flexible so we can more easily do big simulations. The variable Gen_profile is now a string that either contains 'none' (not case-sensitive) to specify no profile (i.e. uniform), or the name of a file with the profile that is to be used. 

Version 3.38 (28 Sep 2017), LJAK
I have changed the Stop_Prog procedure: 1) it only waits for a return by the user if Pause_at_end = 1. If not, the program simply stops. 2) Halt is called with option 3. The latter is the exit code. Normal code: 0, which means no error. 1: general error code (for example division by zero). This exit code can be read by another program such as gdb (GNU debugger), or autoFit. This signals that something went wrong (otherwise SIMsalabim wouldn't stop), for example it couldn't find an input file. 

Also, I have introduced another 'user interface' variable: FullOutput. If this is 1 (true), the normal, previous behaviour is recoverd. If not, then the output is reduced and only the log file will be created and written to. 


Version 3.39 (16 Oct 2017), LJAK
I have changed the way the solar cells parameters are displayed: I've introduced a variable (digits) to limit the number of digits in the screen output of Voc, Jsc, etc. Digits is based on the error estimate of the respective parameters. This error estimate is somewhat crude and does not take any numerical inaccuracies into account. The error estimate is purely based on the interpolation of the current-voltage characteristic. The performance file now also includes the error estimates.

Version 3.40 (18 Oct 2017), LJAK
Fixed a small bug: in 3.39, the program would try to calculate the FF even if Voc = 0. The latter will happen if Vmax < Voc. As a result the program crashes. I moved a few statements, including the one for calculating FF, inside an if-then statement that checks if Jsc and Voc are non-zero. Also, I have added the units of Jsc, Vmpp, Voc, and MPP to the screen output.

Version 3.41 (1 Nov 2017), VLC
I fixed the problem from 3.39 and 3.40 as the program was still crashing when Vmax<Voc. I have added a boolean that is set to FALSE if Vmax<Voc and TRUE otherwise so now the Perf_file is only created if Voc can be calculated and the program should not crash anymore.
I have also added a sentence that suggest to increase the range of V when the Perf_file is not calculated.


Version 3.42 (18 Dec 2017), LJAK
I removed a bug in Init_Generation_Profile that was introduced in 3.35. I have copied the procedure from 3.34, while restoring the functionality introduced in 3.37 (Gen_profile is a string, 'none' or the name of a file). In 3.35-3.41 the generation profile was not correct if the profile was read from a file and the insulators didn't absorb. Now, the profile is first read and put on the grid the program uses. Then, the insulators are made transparent if not InsAbsorb. Lastly, the generation profile is rescaled such that Gmax equals the average of the profile over the length of the absorber. The latter equals L if InsAbsorb or there are no insulators, and L-LIL-LIR otherwise. Function Average_limited_range is now obsolete, so I removed it.


Version 3.43 (3 April 2018), LJAK
I removed a but in Init_Generation_Profile. Previously, if (Gmax=0) and (InsAsorb=0) the program crashed by division by zero. Now, if Gmax=0 the profile is not used (even if one is specified) and the insulators are no longer treated separately. 

Version 3.44 (4 April 2018), VLC
I have cleaned the device_parameters file to make it more consistent. All the mention of n(p)-layer has been replaced by the appropriate name left(right). 
I updated the way the doping is defined in the insulators, now a positive(negative) doping is considered as p(n)-doping. In the same spirit, I changed the setting of the traps. 
For all cases (1) bulk (2) surface (3) grain boundaries the trap density can be specified as positive(negative) for hole(electron) traps.
I also included directly in the device_parameters file the number of grain boundaries and the density of traps at the boundaries.
Now Cn, Cp,Trtype, Etrap and Ttr are common to all the traps no matter where they are.
Fixed a small bug for getting the mob_ion_spec parameter.

Version 3.45 (28 May 2018), VLC
I have removed a small bug on the read_parameters function there was a small space for some of the string of the parameters name.
I also made a small change on the way the grain boundaries are defined.
I fixed (I think) the problem of the precondition. Now it should be set properly.
In addition I added a few line written by Marten to stop the simulation after Voc.


Version 3.46 (20 Sep 2018), LJAK
I have changed the initialisation of the potential and carrier densities. In previous versions this was not correct if there were insulators with LUMO or HOMO offsets. Basically, I copied the code from ZimT 0.27: I moved the init part from the main program to a separate procedure (Init_Pot_Dens). In contast to ZimT, this procedure also inits the array 'empty' (needed for calculating Langevin & SRH Recombination). I have also introduced separate HOMO and LUMO offsets for the left and right insulator, just like in ZimT. Note: the barriers at the contacts (phi_left and phi_right) are still relative to the HOMO and LUMO of the middle layer.
I have also changed the output: Vgn and Vgp are now also stored in the Var_file.

Version 3.47 (5 Nov 2018), VLC
I included a thickness parameters for the grain boundaries such as now the thickness should not depend on on the grid spacing.
I have removed the sign of the trap for all the trap type and just replaced it with one parameter as it was leading to strange results when the sign of the traps was different between the bulk and interface for example.
I have also included the Gfrac parameter (line written by marten) as it facilitate the fit of light intensity vs Voc with autofit. 

Version 3.48 (12 Nov 2018), VLC
I have included a procedure (Calc_Recombi_current) to calculate the recombination currents from Bimolecular, SRH in the bulk and SRH at the left and right interfaces, as well as Jph such as J=Jph+Jbimo+JSRH_bulk+JSRH_LI+JSRH_RI
These currents are now outputted in the JV_file

Version 3.49 (3 Dec 2018), MK
The thickness of the grainboundaries in calculation was twice as big as in the device parameter file, resulting in twice as many traps. This is now fixed.

Version 3.50 (30 Jan 2019), LJAK
See ZimT v. 0.26. I have modified the B function. Very rarely, if the argument is very large and positive (larger than C5), this function returns 0 and this can lead to division by zero in the continuity equation. So, for this case only, we use the full expression for this function (x/(exp(x)-1)) and not the Taylor series.


Version 3.51 (12 Feb 2019), LJAK
I have introduced a new numerical parameter: resetNegDens. If 1, then any negative densities (n[i] or p[i]) will be reset to 1. If not 1, the program will stop if any of the densities are negative.

I have also introduced maxDelV. This is used in the Poisson solver to limit the absolute value of delV[i] in a loop. If abs(delV[i]) is larger than maxDelV*Vt then delV[i] is set to maxDelV*Vt with the appropriate sign.

I have also made a few textual and layout changes to the code.

Version 3.52 (18 Feb 2019), LJAK
I have modified the textual descriptions of the trap densities. Also, I have added a check on grad and the number of grain boundaries. For now, you cannot use grad<>0 with grain boundaries.

Version 3.53 (20 Feb 2019), MK
I have changed the line in Find_Solar_Cell_Parameters where the maximum power is determined. It now compares the power with the highest one found, instead of the previous one in the loop. This eliminates wrong FF values found at low voltage steps.

Version 3.54 (25 Feb 2019), LJAK
I have made a few changes to the layout of the code and I have revised the checking of quit_Voc. Previously, if using a pre-bias we could not use until_Voc. I have also revised procedure Applied_voltage. A change to the procedure Find_Solar_Cell_Parameters: I now pass the number of JV points (NJV) to the procedure. This is done as this number is not fixed if using until_Voc = 1. Previously, using the full JV_Char array, Jsc was not always found because a large part of the array we unused and all the voltage therefore zero.


Version 3.55 (28 Feb 2019), LJAK
I removed a bug from Find_Solar_Cell_Parameters. Previously, the part for finding Voc could cause a range check error (only seen, of course, if compiled with -Cr option) by accessing the JVChar array with index NJV. The first voltage point (excluding any pre-bias) corresponds to index i=0, the last one to index i=NJV-1. Now, the code tries to see if Voc is actually bracketed. If so, then we try to find Voc. It now also works for Vscan = -1.



Version 3.56 (4 March 2019), LJAK
I removed yet another bug from Find_Solar_Cell_Parameters: previously, if simulating only very close to Voc, the FF-part of the procedure could cause a range check error. The procedure starts from i=0 and then looks if the next point has a larger power (= -J*V). If so, that point would be i_start. Next, we would fit a parabola from i_start-1 to i_start+1. However, if you simulate far away from Vmpp, i_start stays 0 and the point at i_start-1 is not part of the array. A range check error is the result. The code now checks if i_start >= 1, which implies that an optimum was found.
Also, in previous versions, the device parameters were always read from device_parameters.txt. In other words, there was a constant called parameter_file but it wasn't used. I also fixed this. 


Version 3.57 (6 March 2019), LJAK
Removed yet another bug from Find_Solar_Cell_Parameters. Sometimes (not sure why), it cannot find Jsc (even though there is a valid point at V=0) but Jsc is not zero. Up till this version, FF would then be calculated (as Jsc<>0) but based on Jsc=0. Weird. Any way, there's a new parameter (calc_Jsc, boolean) to check if Jsc was calculated successfully. Only if calc_Jsc (and a whole load of other conditions) is FF computed.


Version 3.58 (15 March 2019), MK & LJAK
MK:
- Ions: removed update ions needed from code for readability. Removed fix_ions from device_parameters.txt and changed scan_rate to ion_red_rate. Setting ion_red_rate to zero now fixes the ions after initial distribution.
- Mobility models: removed all mobility models but 0, 1, and 5. The tabulated mobility model now also works for holes and is nr 2.
- Traps: changed unit of interface traps and grain boundary traps to m^-2. The traps per volume are now calculated by SIMsalabim based on the actual thickness of the trapping layers on grid, eliminating the dependency of the number of traps on the grid size and grad. Also changed parameter names to better reflect their function. Trap distribution was calculated in main loop and Poisson loop previously, changed this to calculating only once on initialisation.
- Solar cell parameters: changed name of performance file to ScPars_file and changed the error message if the solar cell parameters could not be found to better reflect the error senario.
- Check version (written by LJAK): added version check to SIMsalabim. If the device parameter file has a different version number, an error will be thrown.
- Unused code: removed some code that was commented in SIMsalabim.pas (such as the old FUNCTION B, the Bernoulli function).
- Recombination currents: added surface recombination current to the JV.dat file. Now the currents recombination currents can be added to get the net current from the device. I also changed the input parameters for the Calc_Recombi_current function to only take the parameters it changes.
- Insulators: changed the last point of the isulator to have insulator doping levels instead of intrinsic layer doping levels.

LJAK:
-I have added a check on the version number in the device parameter file. This is not very robust but I think it's good enough: we do this by checking if there is a line that contains both the string 'version' and the string that contains the version number of the program (version). Note, this is not very strict. Example: if the version in the parameter_file is 'version: 13.57' and SIMsalabim is version '3.57', then this function will return true even though it is not correct. However, I don't think that is a problem as it is much more like to run SIMsalabim with a parameter_file that is just slightly older or newer ('3.57' versus '3.52' for example). 
-I made Vscan an integer (was a float).
-I have added a procedure (Tidy_up_parameter_file) to tidy-up the parameter file. This can be done by starting SIMsalabim with the -tidy option. This calls the procedure and SIMsalabim exits once the new parameter file has been written to file.


Version 3.59 (3 April 2019), LJAK
Found a MAJOR bug: in the procedure Calc_Ion_Distribution the total number of ions was only correct if grad = 0 (i.e. a uniform grid). The reason was that to compute the total number of ions, the local ion density was simply summed up, without taking the grid spacing into account. So, I have copied (and adapted) the corresponding procedure from ZimT 0.27 which is correct. 

I have also changed the welcome message. The number of grid points is no longer shown as it is set in the device parameter file.


Version 3.60 (14 May 2019), LJAK
I have decided to break up the code into smaller bits by introducing a number of units (in a folder Units):
1) InputOutputUtils, which contains all the routines for getting strings from a file, etc.
2) TypesAndConstants, which provides all the constants, expect for program version and parameter_file
3) NumericalUtils, which contains all the numerical stuff. 

Smaller changes:
1) Removed the myNonLinFit unit from the list of units to use. We didn't need this at all.
2) In Calc_Recombi_current: First make all the variables zero. This is simply good practice.

Version 3.61 LJAK, MK
1) Replaced all routines and algorithms from the book Numerical Recipes with open-source versions or our own code. For the tridiagonal matrix solver, I have implemented Thomas's algorithm; a version that modifies the original input vectors. This does not present a problem as we pass the vectors as value parameters, not var parameters. The latter would, of course, cause problems. I have slightly stream-lined the Romberg integration algorithm. This algorithm can be found in Numerical Analysis by Burden & Faires. MK wrote a recursive version of the Neville interpolation routine (Interpolation_rec).
2) Removed the Warn_mob_dep parameter from the device parameters. Also removed the option to use the direct Poisson solver. Both have hardly ever been used as far as I know. 
3) I have changed all the doubles to myReal (defined in unit TypesAndConstant.pp) to make it easier to change from double to extended. The size of the reals (in bytes) is written in the log file.
4) I have improved the solver of the ion densities (Calc_Ion_Distribution). This is based on ZimT 0.28. Essentially, we use a better expression for the drift-diffusion equation for the current density, a form that includes the Bernoulli function. This is also the type of expression that is used in SIMsalabim for the electrons and holes. We do this by requiring that the current density of a moving ionic species be zero. That yields the ratio between the ion density at a grid point and the adjacent grid points (based on the electric field). After calculating the resulting profile, we normalise the distribution to get the right overall number of ions. For static species, we simply take the ion density to be constant. 
5) Restructured the type JVList:
-all reals -> myReal
-Added 2 new booleans UpdateIons, Store. These will be used to indicate whether ions are present and moving at some voltage (UpdateIons), and whether the JV point will be stored in the JV file and the JV characteristic used for finding Jsc, Voc, FF in FindSolarCellParameters (Store).
-It is now much more like a task-list: upon initialisation, this list of voltages will function as a to-do list. If there is a pre-bias, this will be point 0 in the array, if there is no pre-biasing then the counter starts at 1. In doing so, I have also modified function Applied_Voltage by removing the check for pre-biasing. The resulting list of voltages-to-be-simulated is written to the log file so the user can check if everything is working correctly (movement of ions, pre-biasing, etc.).
-Note: every voltage calculated will be shown on screen, but only points that converged and that need to be stored (JVData.Store) are stored in the JV_file.
6) Moved the initialisation of the x-positions (x) to procedure Make_Grid.
7) Read_parameters now checks for redundancy of pre-bias: if there is supposed to be a pre-bias (PreCond = 1) and the first voltage (either Vmin or Vmax, depending on Vscan) is equal to the pre-bias voltage (Vpre) then the program will stop. It also checks whether CIM <> 0 (concentration of ions): if there are no ions, it makes no sense to specify a pre-bias.
8) Removed another bug: at the end of the program, last statement, we now close the log file.
9) And removed another bug: the statement IF FullOutput THEN CLOSE(uitv); {if not FullOutput, uitv wasn't open, so it can't be closed} closed the uitv before actually writing info to that file later on.
10) The average dissociation rate of CT states is no longer written to screen.
11) Removed FullOutput.
12) Changed the way the current-voltage characteristics are used in the procedure that finds that solar cell parameters.
13) When writing to the VAR file and the JV file, I've limited the number of decimals by using :nd (nd=25, one of the magic numbers, corresponds to the length of a double). Otherwise, if myReal=extended, Origin cannot read the files!
14) Removed a bug from procedure Init_Hole_Mob_Table: it checked for mob_n_dep = 2, not mob_p_dep!
15) MK wrote the procedure interpolation, this procedure accepts two arrays, x & y, that are to be interpolated. The procedure uses Neville interpolation to make an interpolation of polynomial order n, using n+1 point x & y arrays. The interpolation procedure looks for the consecutive points that together have the lowest offset from the target x-coordinate and sends arrays containing only those points to the Neville interpolation algorithm. The interpolation procedure returns an estimate of y and an error estimate on the y-estimate. The error estimate is the difference between the y-estimate using a polynomial of order n-1 and the estimate using a polynomial of order n.
16) moved the 'magic numbers' to the top of the code: these are a couple of constants (mostly numberical ones) that are used somewhere (as indicated).
17) I have introduced a new procedure (Check_Parameters) that performs a number of checks on the input parameters. ni and Vt need to be calculated BEFORE starting this procedue (that's why Check_Parameters checks if they're not zero).
18) Removed a strang bug (typo, really). No idea when this was introduced in the code. It was a typo in Calc_dissociation, case ThermLengDist = 2 (Gaussian distribution, the one we used the most). There was an a missing after UpperLimBraun: 2 : dp[i]:=RombergIntegration(DissProb_Gauss, LowerLimBraun*a, UpperLimBraun, TolRomb, MaxRombIt, FALSE). Result: zero dissociation probability. 

Version 3.62 VLC
Added Valence,Conduction band and the quasi-fermi levels to Var_file output.
phi_n and phi_p  have been removed


Version 3.63 (14 June 2019) VLC
In version Version 3.32 (16 Mar 2017), TSS changed the expression of the dummy for calculated the trap densities and actually the old implementation was the good one! So I changed it back to what it was.

Version 3.64 (2 & 16 Sep 2019) LJAK
1) I have removed the old (commented) expressions for the hole-trap-dummy in PROCEDURE Solve_Poisson. Does not affect the code, just cleans it up.
2) I have changed the way the rate of direct (BR) recombination is specified:
a) removed Slower_only. We haven't used this in many many years.
b) cleaned up procedure Calc_Langevin_factor.
c) removed Braun_pre. Procedure Calc_Dissociation uses, from now on, the Lang array to get the direct recombination rate in a grid point (still called Braun_rec as this needs to be a global variable). In effect, this means that direct recombination inside and outside the Braun model are the same (which makes the most sense any way).
d) replaced Lang_rec with UseLangevin
e) introduced kdirect to specify the direct, band-to-band, bimolecular recombination rate in case not UseLangevin.
3) When checking if the solar cell parameters need to be calculated, I now also check if Gfrac <> 0.
4) I've changed the naming of the paramters related to the transport layers (previously known as insulators). Syntax: [name variable]_LTL/RTL for left, resp., right transport layer. 
5) I have introduced proper energy levels relative to vacuum: So, Egap is out of the device_parameter_file, but it is still in the code. The main semiconductor's conduction band (CB) and valence band (VB) edges (eV, positive) are specified. The contacts are specified through their work functions (W_L, W_R for work function of left, resp., right electrode, again in eV). phi_left and phi_right are (for now) still used in the code.
6) I have removed the parameters delLL, delRL, etc. and replaced them with the conduction and valence band levels of the left and right TLs (CB_LTL, CB_RTL, VB_LTL, VB_RTL).
7) Removed RombergIntegration2 from the code. This wasn't even used...
8) I have moved the block at the end of the main bit where the variables are written to file to a seperate procedure (Write_Vars_To_File). In this procedure, we also work out the local vacuum level, conduction and valence band, and the quasi-Fermi levels: we can now make a proper band diagram.

Version 3.65 (25 Sep 2019), LJAK
Small change to the units: In TypesAndConstants.pp, types Row and Table used normal (double) reals as the floating point type. This was problematic if using extended reals as myReal (to enable large CIM, ionic densities, for example) and inconsistent with the notion of having reals of the same type throughout SIMsalabim. So, Row and Table are now based on myReal (also defined in TypesAndConstants.pp).


Version 3.66 (18 Oct 2019), LJAK
1) introduced a new parameter (in block 'User interface') AutoTidy. If AutoTidy = 1, then SIMsalabim will tidy-up the parameter file (just like running SIMsalabim with -tidy option) but it will not exit.
2) I have renamed variable JVData as JVSim and introduced another JV curve: JVExp. The latter can contain an experimental JV curve from file ExpJV.
3) If UseExpData = 1 then SIMsalabim will try to read an experimental JV curve from file ExpJV. This file should contain a header ('V J' for example) and then a list of voltages and current densities (A/m2). The voltage step should be constant and it should be only 1 sweep up or down (so not a full loop). This overrides the Vmin,max,step,scan in the parameter file AND the command line. Once the JV has been simulated the two are compared and the rms error and the fit quality (1-rms error) are shown on screen. In a later version this can be extended so a direct comparison between experimental and simulated Jsc, Voc, etc can be made.


Version 3.67 (22 Oct 2019), LJAK
Fixed a small bug introduced in 366: When reading an experimental JV curve, we now force Vdistribution = 1 (the linear one). This was not covered in 3.66 so we could have a situation where Vdistribution=2. Also, if an experimental JV curve is used, the log file will say so (including the resulting voltage parameters).


Version 3.68 (23 Oct 2019), LJAK
1) In reading the experimental JV curve, we now also store Vext and Jext and set Use=TRUE for each voltage point that we read.
2) Added a check before comparing the experimental and simulated JV curves: if Rseries <> 0 then the voltages (Vext) in the two JV curves will be (slightly) different and we can't do a direct comparison. Maybe, in a later version, we can use interpolation to solve this.
3) I have completely revised the way we display the solar cell parameters. I have introduced a new type (TSCPar, a record in TypesAndConstants) to store the solar cell parameters based on a JV curve. We can then store the parameters corresponding to multiple JV curves, for example the simulated and experimental ones. A new procedure, Calc_and_Output_Solar_Cell_Parameters then call a re-written version of the old Find_Solar_Cell_parameters procedure then displays the simulated and experimental Voc, Jsc, etc, and shows the deviation (absolute, i.e. not a relative error) with the experimental JV (if any!). This procedure also uses 4 new magic numbers (see list with constants at the top of the code) to control the output.


Version 3.69 (24 Oct 2019), LJAK
1) removed a small bug (typo?): In Compare_Exp_Sim_JV, the rms error wasn't correct: it was: rms:=SQRT(rms)/count, but should have been rms:=SQRT(rms/count). Oops.
2) Removed the 'fit_quality' output in the same proc as I will adapt autofit to deal with targets that are zero.


Verion 3.70 (29 Nov 2019), Friso Wobben (FWOB)
1) Added normalization of the RMS error to the Compare_Exp_Sim_JV procedure. First we determine the highest (Jmax) and lowest (Jmin) current densities in the simulated and experimental data together. Then normalization of the RMS error happens with respect to the interval [Jmax,Jmin] such that the final rms is rms:=SQRT(rms/count)/(Jmax-Jmin). Instead of 'rms_err: ' now 'norm_rms_error: ' is written to the CLI output, to emphasise that this error is strictly between 0 and 1. Note, we check if the interval [Jmax,Jmin] was different from zero (i.e. larger than tolReal).
2) Added linear interpolation of experimental data to the Compare_Exp_Sim_JV procedure to be able to compare JVs in the case of series resistance. The experimental data is interpolated because simulated data might miss data points (e.g. did not converge), which makes interpolation based on simulated data less reliable as there might be several points in a row missing.
3) JVExp.Vext and JVExp.Jext now store the interpolated values corresponding to the voltages in JVSim.Vext. The interpolation is only done for usable points (within range [Vmin,Vmax]), so JVExp.Use is TRUE for all points that can be used. All point with JVExp.Use equal to FALSE still have their original values (which are equal to JVExp.V & JVExp.J).
4) Added the constraints that there should be at least 5 voltages at which the experimental JV and the simulated JV can be compared.
5) LJAK changed the units of Rshunt to Ohm m2 in the device parameter file comments (was correct in proc Read_Parameters).



Version 3.72 (24 March 2020), LJAK

This version is based on version 3.70, not 3.71.


I have made it possible to compare JV curves based on the logarithm of their current densities, in addition to a comparison of just the normal (linear) values. To do this, I have
0) introduced a new procedure in InputOutputUtils: WarnUser. It is very similar to Stop_Prog, but it doesn't halt the code, it only issues a warning (string) and it can wait for the user to press enter (default is not to wait).
1) introduced a new type: Tfitmode = (linear, logarithmic) in unit TypesAndConstants.
2) introduced a parameter rms_mode in the 'User Interface' block. In the device parameter file, its value can be either 'lin' or 'log' (without the quotes). It is not case-sensitive as it will be made lower case any way. In the code, this is converted to the enumerated type Tfitmode. I have done this because you can then use a case-statement to select the correct way of computing the rms-error. If you had simply used a string variable, you can't use a case-statement, but you would have to use an if-then-else statement instead. Perhaps, in the future we will want to add different ways of calculating the rms-error and that is easier with a case-statement.
3) If some 
4) In Check_Parameters, I have introduced a check to see if the user is attempting to log-fit (rms_mode='log') a solar cell under illumination (this means that UseExpData=true, among other things). If so, a warning is issued.
5) I have removed a commented (obsolete??) version of procedure Find_Solar_Cell_Parameters.
6) Friso Wobben and I have re-written the linear interpolation part of Compare_Exp_Sim_JV so as to avoid a while true loop with a break statement.


Version 3.73 (24 March 2020), LJAK
Removed a bug: In Compare_Exp_Sim_JV, the initialisation of Jmin and Jmax wasn't correct. I changed this to Jmin:=MaxSingle, Jmax:=-MaxSingle.



Version 3.74, (27 March 2020), LJAK

1) Removed a small bug. In line 1903, proc. Calc_and_Output_Solar_Cell_Parameters, there was a mistake which meant that the deviation (simulated versus experimental JV curve) of the FF was not correct.
2) Removed parameter Ext from Find_Solar_Cell_Parameters as we now (not in some older versions) always use the external voltage. => Ext was obsolete. 
3) Removed another bug/error: Previously, if not using an experimental JV curve (so UseExpData = 0), the program would still output a list of experimental Jsc, Voc, etc parameters (all zero) plus a deviation from the simulated data. This is essentially a problem of lack of a proper initialisation of variable SCParExp. By default, or so it appears, booleans are set to true. This means that SCParExp.all_booleans are true and SIMsalabim will output the values of SCParExp.Voc,Jsc,etc. To remedy this, all SCParExp booleans are set to false if UseExpData = 0 or false.



Version 3.75 (2 April 2020), LJAK
1) Introduced a new parameter: rms_threshold. When comparing experimental and simulated data (UseExpData=true), the rms error is only computed if this fraction (rms_threshold) of the total number of voltages calculated has converged. 
2) I have added to proc. Check_Parameters that until_Voc and UseExpData cannot both be true at the same time: If the user wants to use an experimental JV curve then we assume that the voltage range is set by the experimental data. I want to avoid a situation where we use experimental data (UseExpData=true), have a pretty strict rms_threshold (e.g. 1), until_Voc is used, and the last experimental voltage point is much larger than Voc. That would be weird as not all voltages (experimental ones) have been simulated, so rms_threshold will never be 1.
3) At the end of proc Compare_Exp_Sim_JV, I've improved the error and warning messages. So, if the rms-error cannot be computed, the program will give the user a couple of hints and reasons why this is so.


Version 3.76 (15 April 2020), LJAK
I have licensed the code and corresponding units under the GNU LGPL license.



Version 3.77 (3 June 2020), LJAK

0) I noticed a bug when using Rshunt >0: the leakage current would be added twice, first:
Jtot:=Jtot + Va/Rshunt;
and then:
Jext:=Jtot + Va/Rshunt.
This is obviously wrong. So, I corrected this.

1) I have updated the readme.md file.

2) To make it possible for the user to specify the name of the log file I have implemented a number of changes. The name of the log file is set in device_parameters (or via the command line, as per usual), so SIMsalabim has to read the parameters BEFORE it can open a log file (which it did untill this version). Any messages that were previously written to the log file by Read_Parameters are now stored in MsgStr (an ansistring): so, if parameters are set by the command line, their values and names will be stored in MsgStr. Next, Prepare_Log_File opens the log file (name stored in log_file) and writes the contents of MsgStr (if any) to the log file so the user can verify which values were set by the command line. This required a number of changes:
a) I have introduced overloaded versions of Get_Float, Get_Integer, and Get_String in unit InputOutputUtils. The original versions can write to a log file, the new versions can store any messages in an ansistring.
b) Modified Read_Parameters
c) Modified Prepare_Log
d) option '-PIDlog' obsolete, so I have removed this functionality.

3) I have changed the order and names of the columns in JV_file: First are Vext and Vint: the externally applied voltage and the voltage across the device. If there is no Rseries (=0) these would be the same. Next are Jext and Jint: the externally measure current density and the interal current density. If Rshunt is infinite (Rshunt<0) then these would be the same. The order of the other columns remains the same. To make the distinction between the interal and external voltages and current densities, I have renamed them in the type JVList (TypesAndConstants unit). Note, what you measure in an experiment is Jext as a function of Vext.

4) The screen output now lists the internal voltage (Vint) and the internal current density (Jint). I have also made this explicit in the message on screen.

5) I have realised that when using a pre-bias voltage (PreCond = 1) and finite series resistance (Rseries>0) the voltage (pre bias) is not quite correct as the effect of series resistance is not taken into account: the pre-bias (Vpre) is necessarily an internal voltage (Vint). So, SIMsalabim now issues a warning (proc Check_Parameters).




Version 3.78 (22 June, 2020), LJAK
1) I have made it possible to directly read-in the voltages (to be simulated) from an experimental JV curve. In version 3.66, I introduced the possibility of reading experimental JV curves and this also did override the Vmin, Vmax, and Vstep, but only worked for a constant Vstep. So, if the experimental data does not have a fixed voltage step, SIMsalabim would simply not accept it and exit. 
To do this:
a) I have combined Init_voltages_and_tasks with Read_Experimental_JV. Init_voltages_and_tasks now calls Read_Experimental_JV if needed and determines the number of voltage points (NJV). This overrides any NJV based on Vmin, Vmax, Vstep (if Vdistribution = 1) or the value that is directly put if Vdistribution=2.
b) Note: if a pre-bias is used in conjuction with an experimental JV curve, SIMsalabim will still execute the pre-biasing (its voltage is stored in JVSim[0].Vint).

2) Corrected Friso Wobben's initials in the readme.md file and the codes.




Version 3.79 (9-14 July, 2020), LJAK, MK
We have introduced the possibility of having different effective densities-of-states for the main absorber (Nc) and the left (right) transport layers, Nc_LTL(RTL). 

Physical background:
A changing effective DOS can be accounted for by introducing another term in the generalised potentials, Gamma_n and Gamma_p for electrons, resp. holes, see Purbo et al., J. Appl. Phys. 66, 5078 (1989), equations 14 and 15. In previous versions of SIMsalabim, only the effect of different energy levels was implemented (chi in eq. 14 and 15 in Purbo et al.), which led to the introduction of the generalised potentials Vgn/p (see version 3.28).
 
These Gamma's are only defined by their derivative so one can take an arbitrary reference (See: A.H. Marshak, et al., Transport equations for highly doped devices and heterostructures. Solid State Electronics, 30(11), 10891093 (1987)). It is natural to take the Nc of the main layer as the reference for Gamma. So we get:
Gamma_n = Vt * LN(NcLoc[i]/Nc)
Gamma_p = Vt * LN(NcLoc[i]/Nc)
We do not (as yet) allow for different DOS of the conduction and valence band as that would introduce even more parameters. However, this would be a trivial extension as it only affects Gamma_n,p and the intrinsic carrier density (ni).

To do so, we have:
1) introduced parameters Nc_LTL, Nc_RTL to define the effective DOS in the TLs.
2) introduced Nc as a vector: NcLoc, the local Nc.
3) ni is now a vector (no longer a simple float) as it (can) depends on position.
4) ni and NcLoc are initialised in proc DefineLayers (also cleaned up this procedure).
5) In UpdateGenPot the effect of the changing effective DOS (NcLoc) is taken into account by adding a suitable term to Vgn/p. 
6) In proc Write_Vars_To_File, where we work out the quasi-Fermi levels and the conduction and valence bands, we have to correct for the Gamma's.
7) In proc Init_Pot_Dens the densities are initialised but it's different from previous versions. To get the correct n at x=0 and p at x=L, we calculate the injection barrier. Then, we use the law of mass action to get the minority carrier density.
8) Quite a few instances of Nc in the code have been changed to NcLoc: SRH, trapping, finite surface recombination in cont_n,p. Only in Init_Elec/Hole_Mob_Table do we use the bulk value of Nc as the mobility table is only valid for the main absorber layer, not the TLs.

Another minor change: Image force lowering is really only correct if either 1) there are no TLs, 2) if the TLs have the same conduction or valence band as the main layer. This is because the injection barriers (phi_left, phi_right, internal to SIMsalabim) are calculated based on the values of CB and VB (so not CB_LTL, VB_RTL). This is easily fixed, of course, by making CB and VB arrays in the program. However, for now, we simply display a warning message and halt the program. This reasoning also applies to finite surface recombination: also there we rely on phi_left, phi_right, so this is (for now) not possible with TLs that have a band offset.



Version 3.80 (21 Aug 2020), LJAK
Removed a bug in Calc_hole_mob! If we're using a mobility table (case 2 in this procedure), we need to calculate the concentration between two grid points. This is done in line 1314: conc:=0.5*(p[i] + p[i+1]). Previously, n[i] and n[i+1] were used instead!


Version 3.81 (2 Sep 2020), LJAK
Removed a bug from proc Tridiag in the NumericalUtils unit! This proc was modified in version 3.61 to make it open-source. However, the last for loop was not correct (see line 243 in the unit). It should go downto i0, not 1.


Version 3.82 (10 Sep 2020), LJAK
-I have introduced two parameters (nu_int_LTL and nu_int_RLT) to better describe the flow of charges across the interfaces between the TLs (if any) and the main absorber layer. These nu_int's are interface transfer velocities, and thus have the unit of m/s. Internally, they are converted to a mobility at the TL/main absorber interface in a way to ensures that the resulting JV curve does not depend on the grid spacing:
The mobility at the interface (mu_int) is obtained from nu_int by using:
mu_int = delx * nu_int / Vt,
where delx is the (local) grid spacing and Vt is the thermal voltage. 
Note, these nu_int's are the same for electrons and holes, just like the mobilities of the TLs.

-Introduced a new global variable: Vti = 1/Vt. We use this throughout the code, so I have removed all local equivalent declarations and have replaced things like .../Vt with ...*Vti. Multiplication is typically an order of magnitude faster than division!


Version 3.83 (11 Sep 2020), MK
- I removed a bug affecting the interface trapping layer. If the layer was set to a thickness lower than the grid spacing, there would be no traps added to the interface. Now the traps are applied to at least one gridpoint. The number of traps per cubic meter is according to the actual length on-grid, not the set layer thickness (this is the same behaviour as in the previous versions).

Version 3.84 (4 Dec 2020), MK
- I changed interface traps and grain boundary traps. Interface traps can now capture across the interface between transport layer and main layer.
- Traps in general have been reworked in the code. In the device parameter file, one can still make hole and electron traps, but they now share the same energy level defined with respect to vacuum. Because of symmetry between different trap types, the distinction between hole and electron traps is removed in the code. For every trap we now save the number of traps and whether it is charged when filled with an electron yes or no. The fraction of filled traps now refers to the fraction filled by electrons. Interfaces now have their charge distributed over 2 grid points. This removes the need for parameters defining the thickness of the trapping layers.
- A check was added to make sure that the trap level is between the conduction and valence band everywhere in the device. Shallow traps can still become unstable depending on the DOS offset in between the bulk and transport layers.
- The conduction band and valence band are now vectors that can be used to get their respective levels.
- Bulk doping previously added doping in transport layers as well if they were undoped, this is now fixed.
- Helper functions are introduced to calculate the filled fraction of traps for both bulk and interface traps.
- The Poisson solver has been updated to account for the new interface traps. The expressions for both bulk and interface traps have been linearized in delV to aid convergence. Previously this was not done so this could positively affect convergence.
- The Recombi and Calc_recombi_current functions were updated to account for the new type of traps.
- The continuity equations are updated to account for the new interface traps. While the equations are linearized with respect to carrier densities, they are still prone to overshoot the solution. When close to the value where the equations converge, the overshoot disappears. A likely cause for the overshoot is the dependence of the carrier densities at the interfaces on their neighbouring sites, however this is pure speculation. A way to assess this system would be to look at the spectra of the continuity matrix, but for now a heuristic is applied to make the continuity equations converge.
- The new definition of interface traps allows for current to be conducted through traps by e.g. by the interface trap capturing electrons from one side and having them detrap at the other side. This is especially apparent when there are shallow traps and a low interface transfer rate. This current is added to the regular current term in the Var.dat file.
- The new expression for the continuity equations make the main loop converge with more difficulty. Therefore a few changes are made to the main loop. We call contn and then call contp with the newly calculated n, which is different from the previous version where the old n was used. I also implemented a heuristic way of limiting the maximum deln and delp. When both deln and delp start oscillating (changing sign over iterations), we set the new maximum for deln and delp to half of the maximum deln and delp found. To check for convergence we use deln and delp as calculated from the continuity equations, so before they are limited. This way we do not artificially converge the system.
- In the Var.dat file we now output ctraps (charge traps) instead of n_trap and p_trap, where ctraps is the total charge of all traps.
- I introduced a variable in device parameters 'Exit_after_fail', which makes SIMsalabim stop after the first failure to converge. This is useful as when running autofit, it can be useful to now wait for all points to not converge but give up after the first fail, saving time and poor estimates of the solar cell parameters.

Version 3.85 (14 Jan 2021), MK
- Fixed the calculation of finite surface recombination. Removed the terms cathode and anode from the parameters so everything is now refering to left and right. Finite sufrace recombination is now only used when there is extraction.
- Added a parameter to the user interface parameters: exit_after_fail. This parameter exits SIMsalabim with exit status 1 if a point does not converge. This is especially usefull when running in combination with autofit, where a certain part of the parameter range might not converge. This parameter makes sure that no bogus FF and Voc vanues are calculated and just generally speeds up autofit.
- Added a parameter to allow ions in the TL's.
- Fixed the comment for Etrap in the device parameter file.
- Fixed some indentation and whitespace issues.

Version 3.86 (14 Jan 2021), MK & LJAK
- Fixed linearization traps in Poisson equation. This improves convergence of the Poisson solver.
- Traps were allowed on the same energy as the conduction or valence bands. This is now forbidden, as it is unphysical.
- Fixed bug in the diagonal entries of the continuity equations regarding interface traps.
- Added binaries for Windows and (GNU) Linux
- Fixed whitespace in SIMsalabim.pas. It was wrong because of tab and space mixing for indentation.
